# 람다를 활용한 정렬 - 사용시 +  역으로 작은순기준 정렬 
li.sort(key = lambda x: ( int(x[3]) , int(x[2]) , int(x[1])))

좋은 문제 
1) 숨바꼭질
import sys

from collections import deque
input = sys.stdin.readline

def bfs():
    q = deque()
    q.append(n)
    while q:
        x = q.popleft()
        if x == k:
            print(dist[x])
            break

        for j in (x-1,x+1,x*2):
            if 0<=j<=MAX and not dist[j]:
                dist[j] = dist[x] +1
                q.append(j)


MAX = 100000 #문제에서의 제한사항이 0~100000이라서
n,k = map(int,input.split())
dist = [0] * (MAX+1)

bfs()
'''
x = 5, j = 4, 6, 10

4, 6, 10은 0과 MAX 사이의 값 dist [4, 6, 10] = dist [5] + 1 = 0 + 1 = 1

 

x = 10으로 바로 넘어가면 j = 9, 11, 20

9, 11, 20은 0과 MAX 사이의 값 dist [9, 11, 20] = dist [10] + 1 = 1 + 1 = 2

 

dist [10]= 1인 이유는 위 x=5일 때 1이 추가되었다.

 

x = 9, j = 8, 10, 18

8, 10, 18은 0과 MAX 사이의 값 dist [8, 10, 18] = dist [9] + 1 = 2 + 1 = 3

 

x = 18, j = 17, 19, 36

17, 19, 36은 0과 MAX 사이의 값 dist [17, 19, 36] = dist [18] + 1 = 3 + 1 = 4

 

위 def bfs 5번 문항인 만약 그 x의 값이 동생이 있는 위치 k일시 dist [x]를 출력하고 프로그램 종료를 만족

따라서 4 


출처 : https://tooo1.tistory.com/111
'''

* 파이썬은 재귀 사용시 재쉬 시간제한 걸려있으니깐 
import sys
sys.setrecursionlimit(10000)


* (구분자.join(리스트))
join 함수는 매개변수로 들어온 리스트에 있는 요소 하나하나를 합쳐서 하나의 문자열로 바꾸어 반환하는 함수
